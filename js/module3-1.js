'use strict';

// // ❗️❗️❗️ Об'екти
// // Об'ект - це головна сутність в JS. Масив та функція є часними випадками об'ектів. Об'ект дозволяє сгруппувати та описати характерістики певних сутностей (книга, користувач, аудіотреек...). Об'ект містить в собі властивості описуванної сутності у вигляді имені властивості та ії значення (ключ:значення, key:value).
// Об'ект це не індексована, але ітерабельна сутність (тобто, те що записано в об'екті можна перебрати та отримати доступ до влативостецй та їх значень). Звернення до властивостей виконується до ключах, та іх місце в об'екті не має значення.
// масиви та функції - це часні випадки об'ектів
// console.dir() // повертає сутність у вгляді об'екту

// // Створення об'екту, литерал об'екту
// // Літералом об'екта е фігурні дужки ( {} ). Об'екти можуть існувати тільки справа від  знака рівно ( = ) - операція присвоення (таким чином створюеться об'ект), а тком після операцій присвоєння: передача аргумента (присвоення) в параметр функції, та повернення об'екта після виконання фунекції

// // 1
// const obj = {}; // операція присвоення та створення об'екту

// // 2
// // console.log({}); //  з передача об'екту для використання в функції, де виконується операція присвоення аргумента як об'екта в параметрі функції
// const fn = function (myObject) {
//   // myObject = { a: 1 } // присвоення - аргумент записутьбся в параметр
//   console.log(myObject);
// };
// fn({ a: 1 });

// // 3
// const rtrn = function() {
//   return {}; // повернення об'екта, отнриманного при виконанні функції
// }

// Властивості
// Кожен об'ект описуеться за допомогою властивостей, яки складаються з ключа (key) та його значення (value). Семантично, назва ключа це рядок (тому при роботі з ключамі об'екта до ніх потрібно звертатися як к рядку). Значенням властивости може бути що завгодно: примітив (рядки, числа, булі, null і undefined) або складні типи(масив, об'ект (вкладений), який в сіою чергу теж має властивості), а також функції (яки використовуються для роботи з властиволстями цього обїекту). Властивості перераховуються через кому - обов'язково на приуінці кожної властивості, навіть для останньої

// const user = {
//   name: 'Vitalii',
//   age: 45,
//   skills: {
//     html: true,
//     css: true,
//     js: true,
//     nodeJs: false,
//   },
//   hobby: ['hiking', 'computer programming'],
//   fn() {
//     console.log(`${this.name} - ${this.age} y.o.`);
//   },
// };
// //

// // звернення до властивостей (через крапку)
// // для доступу до властивості використовуються 2 методи: через крапку та через квадратні дужки. Через крапку:
// console.log(user.name); // 'Vitalii'
// // також можно звернутися до вкладенної властивості:
// console.log(user.skills.html); // true
//  user.fn(); // 'Vitalii - 46 y.o.'

// // звернення до властивостей через квадратні дужки. В такому випадку виконується звернення до ключа накшталт звернення до індексу в масиві.
// console.log(user['name']); // 'Vitalii' - в такому випадку для звернення до ключа в дужках його назва вказується як радок.
// // Через дужки виконується звернення до ключа властивості в тіх випадках, коли заздалегіть не відома його назва (наприклад, вогна вирахована зі змінної при переборі в ціклі)

// // додавання ключів. Для додавання ключів в об'ект виконується операція присвоення:
// user.hasChildren = true;

// // видалення властивості
// delete user.hasChildren;

// // зміна значення властиволсті. Для зміни значння власстивості також викоритовується операція присвоення - якщо така властивість існує - значення змінюється, якщо не існує -властивість додаеться:
// user.age = 46;

// // для зміни складноі властивості використовуються методи той властивості,ю яку потрібно змінити:
// user.skills.react = false;
// user.hobby.push('WOT');
// console.dir(user);

// коротке звернення до властивості
// В випадках, коли в об'ект необхідно додати властивість зі одноїменної змінної, використовується коротке звернення:

// const name = 'Vitalii';
// const age = 46;

// const user = {
// //   name: name, // ім'я властивості ідентично змінної, з якої береться значення
// //   age: age, //  ім'я властивості ідентично змінної, з якої береться значення
//   name, // коротке звернення
//   age, // коротке звернення
// };

// console.dir(user); // результат в обох випадках однаковий, але коротке звернення зручнише та частише виколристовується

// обчислювані властивості.
// Бувають випадки, еоли нам заздалегіть ми не знаємо, то му що воно може зберігатися у якості значення змінної або бути передана нам в якості результату виконання функції. В таком випадку може бути використано 2 підходи:

// Застарілий:
// // оголошення зманної з назвою властивості, яку необхідно додати:
// const propName = 'name';
// // створення об'екта
// const user = {
//     age:46,
// }
// // отримання значення для властиволсті з функції
// user[propName] = 'Vitalii';
// console.dir(user);

// Сучасний:
// // оголошення зманної з назвою властивості, яку необхідно додати:
// const propName = 'name';
// // створення об'екта
// const user = {
//   age: 46,
//   // ім'я властиволсті буде взято зі значення propName:
//     [propName]: 'Vitalii',
// };
// console.dir(user);

// ❗️❗️❗️ Методи об'екта
// Для об'екта можуть бути додані методи або функції, яки будуть використовуватися саме для обробки властивостей та іх значень того самого об'екта. Якщо властивість об'екта - це функція, то вона зветься методом об'екта.

// Доступ до властивостей обї'екта в методах (this). При використанні функції-метода об'екта для неї використовується ключове слово 'this'. 'this' виконує операції з тім об'ектом, котрий його викликає - особливо наявно апри роботі з прототипнимі об'ектамі.

// const user = {
//   name: 'Vitalii',
//   age: 45,
//   skills: {
//     html: true,
//     css: true,
//     js: true,
//     nodeJs: false,
//   },
//   hobby: ['hiking', 'computer programming'],
//   getNameAge() {
//     console.log(`${this.name} - ${this.age} y.o.`);
//   },
//   getCountHobby() {
//     return this.hobby.length;
//   },
// };
// // user.getNameAge(); // 'Vitalii - 46 y.o.'
// // console.log(user.getCountHobby()); // 2

// Цикл for...in
// В зв'язку з тим, що об'ект то не ітерабельний елемент, то для нього не підходе цікл пребору for...of. На зміну його використовується цікл пошуку for...in - для перебору ключів об'екту та отримання іх назв та/або значень (нибито ітерування по ключах):
// for (const key in object) {
//     // інструкція
// }

// const user = {
//   name: 'Vitalii',
//   age: 45,
//   skills: {
//     html: true,
//     css: true,
//     js: true,
//     nodeJs: false,
//   },
//   hobby: ['hiking', 'computer programming'],
//   getNameAge() {
//     console.log(`${this.name} - ${this.age} y.o.`);
//   },
//   getCountHobby() {
//     return this.hobby.length;
//   },
// };

// for (const key in user) {
//   // ключ
//   console.log(key);
//   // значення
//   console.log(user[key]);
// }

// Метод Object.create()
// Створює новий об'ект на основі прпототипу. Наслідує, але не додає в новий об'ект значення прототипу. Але при зміні властивостей, власних прототипу, створює власну, змінену властивість.
// const user0 = {
//   name: 'Vitalii',
//   age: 46,
// };
// // console.log(user0);
// const user1 = Object.create(user0);
// user1.name = 'Denys';
// user1.age = 0;
// user1.stat = 'inFuture';
// console.log(user1); // Змінено тільки ім'я, все останне береться з прототипу

// Прототипне наслідування
// Якщо об'ект створено з прототипа, то при виводі його в консоль видображаються всі властивості йго, як особисті так і наслідувані.

// Метод hasOwnProperty()
// Повертає буль приналежності влвтивості тої сутності (об'екту) для котрого він викликаний (при роботі з протипованнимі об'ектамі). Використовується при переборі за допомогою for...in для відображення значень ліше власних властивостей

// for (let key in user1) {
//   if (user1.hasOwnProperty[key]) {
//     console.log(user1[key]); // Denys (??? не зрозумило, чому тільки 1 значення повертає)
//   }
// }

// console.log(user1.hasOwnProperty(stat)); // false

// Метод Object.keys()
// Повертає масив власних ключів об'екиту ['key0', 'key1', ... 'keyZ']
// console.dir(user.Object.keys());
// console.dir(user2.Object.keys());

// Метод Object.values()
// Повертає масив значень власних ключів об'екта ['value0', 'value1',...'valueZ']

// Метод Object.entries()
// Повертає масив зі значенням ['key', 'value']

// Метод Object.freeze()
// "Заморожує" вказаний об'ект - захищає його від будь якогої зміни

// Метод Object.assign()

// * id: Date.now() - оголошення id по поточної даті в мілісекундах

// ❗️❗️❗️ Масив об'ектів
