// // ❗️❗️❗️ Чисти функції
// Функції з побічними ефектами - ті, які використовують або змінюють глобальні змінні, змінюють аргументи, виконують операції введення-виведення. Це мутуючи функції.
// Чисти функції - ті, які не змінюють аргументів, та не мутують вхідні значення та повертають нові набори значень.

// // ❗️❗️❗️ Перебираючи методи масиву
// В свої більшості перебираючи методи масиву є чисти функції, та мають схожий синтаксис:
// array.method(callback(item, idx, array)) {};
// де:
// array0 - вхідний масив
// method - назва методу
// callback - колбек-функція, як аргумент методу, та своїми параметрами:
// item - значення елемента
// idx - індекс елемента
// array - посилання на вхідний масив для колбека, якщо в тілі колбек-функції необхідно використовувати таке посилання (наприклад, виконати мутування)

// ❗️❗️❗️ Метод forEach(). Метод масиву.  Перебирає абсолютно всі елементи масиву без лічильника, та виконує передану колбек функцію.
// Умовно мутуючий - може змінювати масив, з котрим працює (але не обов'язково)
// Для кожного перебираючого методу масиву потрібно розуміти:
// 1. що він робіть
// 2. що приймає
// 3. що повертає
// forEach () має 2 аргументи: колбек-функція та об'єкт, в контексті котрого буде викликатися цей колбек

// const numbers = [5, 10, 15, 20, 25];

// // Класичний for
// for (let i = 0; i < numbers.length; i += 1) {
//   console.log(`Індекс ${i}, значення ${numbers[i]}`);
// }

// // Метод перебирання forEach
// numbers.forEach(function (number, index) {
//   console.log(`Індекс ${index}, значення ${number}`);
// });

// Метод forEach неможливо перервати, тому якщо потрібно перервати перебирання масиву значень в якийсь момент (знайдено потрібне число) то варто використовувати класичний for

// // Приклад: помножити на 2 кожен елемент масиву
// const arr = [1, 2, 3]
// arr.forEach(function (item, idx, arr) {
//   arr[idx] = item * 2; // вказуємо, що в вихідному масиві для кожного елементу ( arr[idx] - звернення по індексу) виконуємо операцію - перевизначаємо елемент
// })

// console.log(arr); // [2, 4, 6] - мутований масив

// // ❗️❗️❗️ Метод map()
// Використовується для трансформації масиву. Приймає масив, повертає новий масив по результату виконання колбек-функції. Вхідний масив залишається незмінним. Метод перебирає вхідний масив, виконує передану колбек-функцію та повертає новий масив.
// 1. Перебирає всі елементи вхідного масиву
// 2. Не змінює оригінальний масив
// 3. Результат колбек-функції записується в новий масив
// 4. Вихідний масив має таку ж довжину, що і вхідний

// const names = ['Vitalii', 'Inna', 'Denys'];
// const namesToUppertCase = names.map(name => name.toUpperCase());
// const namesToLowerCase = names.map(name => name.toLowerCase());

// console.log(namesToUppertCase); // ['VITALII', 'INNA', 'DENYS'];
// console.log(namesToLowerCase); // ['vitalii', 'inna', 'denys'];
// console.log(names); // ['Vitalii', 'Inna', 'Denys'] - вхідний масив не змінено

// // перебір масиву об'єктів:
// const family = [
//   { name: 'Vitalii', age: 46 },
//   { name: 'Inna', age: 27 },
//   { name: 'Denys', age: 0 },
// ];

// const familyNames = family.map(person => person.name);
// console.log(familyNames); // ['Vitalii', 'Inna', 'Denys']

// // ❗️❗️❗️ Метод flatMap()
// Метод також перебирає масив та вкладений масив, та повертає масив значень вкладеного масиву (тільки на глибину однієї вкладеності, тобто дочірнего (значення масиву в масиві)):

// const children = [
//     { name: 'Vitalii', ownChildren: ['Myroslava', 'Denys'] },
//     { name: 'Ann', ownChildren: ['Anastasia'] },
// ];
// const grandChildren = children.flatMap(child => child.ownChildren);

// console.log(grandChildren); // ['Myroslava', 'Denys', 'Anastasia']

// // ❗️❗️❗️ Метод filter(callback)
// Використовується для фільтрації масиву - коли необхідно обрати кілька елементів вхідного масиву за певними критеріями/умовами
// array.filter(item, idx, array) => { тіло колбек-функції }
// 1. Не змінює оригінальний масив
// 2. Перебирає всі елементи вхідного масиву
// 3. Повертає новий масив
// 4. Додає в вихідний масив ті елементи, що відповідають умові колбек-функції: якщо колбек функція повертає true - елемент додається в новий масив, якщо false - ні; якщо жоден елемент не відповідає умові - повертає порожній масив

// const numbers = [1, 2, 3, 4, 5, 6];
// const multipleOfTwo = numbers.filter(number => !(number % 2));
// const multipleOfThree = numbers.filter(number => !(number % 3));

// console.log(multipleOfTwo); // [2, 4, 6]
// console.log(multipleOfThree); // [3, 6]

// ❓❓❓ Пошук та відбір унікальних елементів - ???
// const students = [
//   { name: "Манго", courses: ["математика", "фізика"] },
//   { name: "Полі", courses: ["інформатика", "математика"] },
//   { name: "Ківі", courses: ["фізика", "біологія"] },
// ];

// const allCourses = students.flatMap(student => student.courses);
// // ['математика', 'фізика', 'інформатика', 'математика', 'фізика', 'біологія'];

// const uniqueCourses = allCourses.filter(
//   (course, index, array) => array.indexOf(course) === index
// );

// console.log(uniqueCourses);

// // ❗️❗️❗️ Метод filter() для масиву об'єктів
// При роботі з масивом об'єктів метод filter() створює новий масив об'єктів, відфільтрованих за певною умовою

// const LOW_SCORE = 50;
// const HIGH_SCORE = 80;
// const students = [
//   { name: "Манго", score: 83 },
//   { name: "Полі", score: 59 },
//   { name: "Аякс", score: 37 },
//   { name: "Ківі", score: 94 },
//   { name: "Х'юстон", score: 64 },
// ];

// const best = students.filter(student => student.score >= HIGH_SCORE);
// console.log(best); // Масив об'єктів з іменами Манго і Ківі

// const worst = students.filter(student => student.score < LOW_SCORE);
// console.log(worst); // Масив з одним об'єктом Аякс

// // В колбек-функції зручно деструктуризувати властивості об'єкта
// const average = students.filter(
//   ({ score }) => score >= LOW_SCORE && score < HIGH_SCORE
// );
// console.log(average); // Масив об'єктів з іменами Полі і Х'юстон

// // // ❗️❗️❗️ Метод find()
// // Метод виконує пошук першого збігу в масиві. Повертає елемент, для якого колбек-функція повернула true, після чого припиняє пошук. Якщо не знайдено жодного елемента, відповідаючого умові, то повертається undefind.
// Найчастіше використовується для пошуку по унікальної властивості.
// // array.find((item, idx, array) => { тіло колбек-функції })

// const users = [
//   { name: 'Jonh', status: 'active' },
//   { name: 'Joody', status: 'snooze' },
//   { name: 'Tom', status: 'active' },
//   { name: 'Mary', status: 'snooze' },
// ];

// console.log(users.find(user => user.status === 'snooze')); // { name: 'Joody', status: 'snooze' } - повернув тільки перший збіг

// // // ❗️❗️❗️ Метод findIndex()
// // Використовується як аналог indexOf. Дозволяє задати складні умови, ніж рівність. Повертає індекс першого елемента, який відповідає (true) умовам колбек-функції, або -1, якщо для всіх елементів колбек повернув false. Працює як з примітивами, так і з об'єктами в масиві.
// // array.findIndex((item, idx, array) => { тіло колбек-функції })
// console.log(users.findIndex(user => user.status === 'snooze')); // 1

// // // ❗️❗️❗️ Метод every()
// // Перевіряє, чи проходять всі елементи перевірку колбек функції, та повертає true або false.
// // Усі елементи більші або дорівнюють нулю? - так
// [1, 2, 3, 4, 5].every(value => value >= 0); // true

// // Усі елементи більші або дорівнюють нулю? - ні
// [1, 2, 3, -10, 4, 5].every(value => value >= 0); // false

// // // // ❗️❗️❗️ Метод some()
// // Перевіряє, чи проходить хоча б один елемент перевірку колбек функції, та повертає true або false. Припиняється, коли повертає true
// // Чи є хоча б один елемент, що більший або дорівнює нулю? - так
// [1, 2, 3, 4, 5].some(value => value >= 0); // true

// // Чи є хоча б один елемент, що більший або дорівнює нулю? - так
// [-7, -20, 3, -10, -14].some(value => value >= 0); // true

// // Чи є хоча б один елемент, що менший нуля? - ні
// [1, 2, 3, 4, 5].some(value => value < 0); // false

// // Чи є хоча б один елемент, що менший нуля? - так
// [1, 2, 3, -10, 4, 5].some(value => value < 0); // true

// // ❗️❗️❗️ Методи every() і some() для масиву об'єктів
// const fruits = [
//   { name: "apples", amount: 100 },
//   { name: "bananas", amount: 0 },
//   { name: "grapes", amount: 50 },
// ];

// // every поверне true тільки, якщо усіх фруктів буде більше 0 штук
// const allAvailable = fruits.every(fruit => fruit.amount > 0); // false

// // some поверне true, якщо хоча б одного фрукту буде більше 0 штук
// const anyAvailable = fruits.some(fruits => fruits.amount > 0); // true

// // // ❗️❗️❗️ Метод reduce(callback, initialValue)
// Виконує послідовну обробку кожного елемента масиву зі збереженням проміжного результату, як акумулятор.
// Використовується, коли потрібно взяти багато та привести до одного. Частіше використовується для роботи з числами.
// array.reduce((previousValue, element, index, array) => {
//   // Тіло колбек-функції
// }, initialValue);
/* не змінює вхідний масив
 * поелементно перебирає вхідний масив
 * повертає що завгодно
 * робіть все що завгодно
 */

// const total = [1, 2, 3, 4, 5].reduce((previousValue, number) => {
//   console.log(previousValue);
//   return previousValue + number;
// }, 0); // 0 - початкове значення акумулятора, або initialValue – ініціююче значення (необов'язково, принаймні для поточного прикладу)
// console.log(total); // 15
// // previousValue - проміжний результат: 0 1 3 6 10 - проміжне значення total на кожній ітерації

//
// const total = [1, 2, 3, 4, 5].reduce((previousValue, number) =>
//      previousValue + number
// );
// console.log(total); // 15

// // ❗️❗️❗️ Метод reduce() для роботи з масивом об'єктів
// при роботі з масивом виконується редукування за значенням певної властивості, наприклад отримання середнього значення

// const students = [
//   { name: 'John', score: 10 },
//   { name: 'Joody', score: 6 },
//   { name: 'Mary', score: 8 },
//   { name: 'Tom', score: 9 },
// ];

// const totalScore = students.reduce((total, student) => {
//     console.log(total);
//     return total + student.score;
// }, 0); // початкове значення total обов'язкове - до нього підсумовуються інші значення - інакше буде конкатенація
// console.log(totalScore); // 33

// const averageScore = totalScore / students.length;
// console.log(averageScore); // 8.25

// ❓❓❓ Просунутий reduce

// // ❗❗❗ Метод sort()
// Сортує елементи масиву по значенню Unicode першого символу за зростанням
// повертає відсортований вхідний масив - мутуючий метод (не чиста функція)
// при сортуванні значення приводяться до рядка
