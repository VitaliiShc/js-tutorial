// // // ❗️❗️❗️ Функції
// Функція це підпрограма, незалежна частина коду, яка призначена для багаторазового використання для рішення однієї задачі з різними початковими значеннями. Кожна функція виконує однотипну дію, відрізняються тільки вхідні параметри.
// Function declaration - оголошення фуенкціі з ім'ям та зверненя до неї по імені. Результат функції може буцти отриманий з любого місця коду, як після оголошення функціі, так і до неї

// const arr1 = [1, 2, 3];

// multipl(arr1); // [2, 4, 6]

// function multipl(arr) {
//   for (let i = 0; i < arr.length; i += 1) {
//     arr[i] *= 2;
//   }

//   console.log(arr);
// }

// const arr2 = [2, 4, 6];

// multipl(arr2); // [4, 8, 12]

// Function expression - Функціональний вираз, оголошенняя функції за допомогою змінної, та звернення до неї по ім'яні змінної. Сама функція не має назви, а назву має змінна, в яку передається результат виконання функції. Результат функції може бути отриманий тільки після ії оголошення- тому що результат, це змінна.
// const arr1 = [1, 2, 3];

// multipl(arr1); // буде помилка, тому що змынна, до котроъ звертаэться вираз не оголошено раныше

// const multipl = function (arr) {
//   for (let i = 0; i < arr.length; i += 1) {
//     arr[i] *= 2;
//   }

//   console.log(arr);
// };

// const arr2 = [2, 4, 6];

// multipl(arr2); // [4, 8, 12]

// // Псевдомасив arguments
// функції можна передати довільну кількість аргументів, без необходності перераховувати іх в параметрах, за допомогою спеціальної змінної arguments. В такому випадку в парметри функції передається ітерабельний (доступний для перебору) перелік індексованих єлементів, та функція використовує їх для виконання.
// але arguments - це не масив, а набір індексованих елеменів, тому для нього не доступна більшисть методів масиву, тому якщо в функції необхідно застосовувати матоди масиву, то перелік аргументів необхідно привети до масиву за допомогою методів:
// // Array.from(arguments) - перетворює вісь набір аргументів в масив. Метод викликається на псевдомасиві після отримання аргументів

// add(1, 2, 3, 4)

// function add() {
//   console.log(arguments); // Arguments(4) [1, 2, 3, 4, callee: (...), Symbol(Symbol.iterator): ƒ] - псевдомасив
//   const array = Array.from(arguments);
//   console.log(array); // [1, 2, 3, 4] - повноцінний масив
// }

// // або за допомогою оператора (...rest) - дозволє одразу зібрати в масив вісь, або частину переліку за виключенням довільної кількості єлементів з початку переліку(розпилює перелік.
// add(1, 2, 3, 4);
// function add(...array) {
//   console.log(array); //[1, 2, 3, 4] - одразу повноцінний масив
// }

// Оператор return - явне завдання, що потрібно повернути з функції, та після виконання return функція переривається, та все, що було вказано після return використовуваться не буде - виконується вихід з функції.
// Ретурнів може бути кіфлька в функції, якщо в якіх ось випадках потрібно перервати виконання функції за умовою =- патерн ранього повернення, наприклад при виконання розгалужень, або ціклів

// Дефолтні значення
// Якщо в функції передумовлено використання явної кількості значень, а прийде кількість знаяень, меньша за розрахункове, то може виникнути помилка, тому що для очикуваних, але не переданих знаяень буде встановлено undefound. Щоб такого уникнути, для параметрів потрібно додати дефолтне значення, наприклад дорівнюване 0 (зазвичай - найменьше, від розраховуваних значень (0, '', [])):

// function sum(val0, val1 = 0) {
//   return val0 + val1;
// }
// console.log(sum(1, 2));
// console.log(sum(5));
// console.log(sum(3));

// // Приклад задачи: отримати з масиву різно значних єлементів однорівненивий масирв:

// // отримується набір аргумкентів для побудови кеінцевого масиву:
// function flatArray(array) {
//   // оголошуємо змінну, в яку будемо збирати отримани аргументи з порожнім вмістом
//   const newArray = []; 
//   // основна логіка - принцип, за яким будемо наповнювати масив кінцевого результату:
//   // запускаємо цикл for...of для перебору на кожній операції єлементу з заданого масиву, де elem - отриманий аргумент, array - масив отриманих аргументів:
//   for (const elem of array) {
//     // задаемо умову, чи єлемент є масивом, використовуючи метод Array.isArray для єлемента (повертає true або false) - якщо true, то потрапляння в тіло if, інакше - виконується код в else:
//     if (Array.isArray(elem)) {
//       // виконання коду, при умові true (елемент є масивом) - кожен item вкладеного масиву окремо пушиться в newArray:
//       for (const item of elem) {
//         newArray.push(item);
//       }
//     }
//     // якщо elem не масив (тобто, Array.isArray повернуло false, та мінули тіло if), то додання цього elem до newArray:
//     else {
//       newArray.push(elem);
//     }
//   }
//   return newArray; // повернення результату
// }

// // Бынго! Але з масивами 1-го рівня вкладенності, якщо масиву будуть 2-го та нижче рівня вкладенності, потрібно ще перевіряти
// console.log(flatArray(['a', 5, ['3', 7, 8], '45', [1, 3, 7, 8]])); // ['a', '5', '3', '7', '8', '45', '1', '3', '7', '8']

// // Паттерн ранього повернення
