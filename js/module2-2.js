// // ❗️❗️❗️ Функції
// // Функція це підпрограма, незалежна частина коду, яка призначена для багаторазового використання для рішення однієї задачі з різними початковими значеннями. Кожна функція виконує однотипну дію, відрізняються тільки вхідні параметри.
// // ❗️ Function declaration - оголошення функції з ім'ям та звернення до неї по імені. Результат функції може бути отриманий з любого місця коду, як після оголошення функції, так і до неї

// const arr1 = [1, 2, 3];

// multipl(arr1); // [2, 4, 6]

// function multipl(arr) {
//   for (let i = 0; i < arr.length; i += 1) {
//     arr[i] *= 2;
//   }

//   console.log(arr);
// }

// const arr2 = [2, 4, 6];

// multipl(arr2); // [4, 8, 12]

// // ❗️ Function expression - Функціональний вираз, оголошення функції за допомогою змінної, та звернення до неї по імені змінної. Сама функція не має назви, а назву має змінна, в яку передається результат виконання функції. Результат функції може бути отриманий тільки після її оголошення- тому що результат, це змінна.

// const arr1 = [1, 2, 3];

// multipl(arr1); // буде помилка, тому що змінна, до котрої звертається вираз не оголошено раніше

// const multipl = function (arr) {
//   for (let i = 0; i < arr.length; i += 1) {
//     arr[i] *= 2;
//   }

//   console.log(arr);
// };

// const arr2 = [2, 4, 6];

// multipl(arr2); // [4, 8, 12]

// // ❗️ Оператор return - явне завдання, що потрібно повернути з функції, та після виконання return функція переривається, та все, що було вказано після return використовуватися не буде - виконується вихід з функції.
// // Ретурнів може бути кілька в функції, якщо в яких ось випадках потрібно перервати виконання функції за умовою =- патерн раннього повернення, наприклад при виконання розгалужень, або циклів

// // ❗️❗️❗️ Псевдомасив arguments
// // функції можна передати довільну кількість аргументів, без необхідності перераховувати їх в параметрах, за допомогою спеціальної змінної arguments. В такому випадку в параметри функції передається ітерабельний (доступний для перебору) перелік індексованих елементів, та функція використовує їх для виконання.
// // Але arguments - це не масив, а набір індексованих елементів, тому для нього не доступна більшість методів масиву, тому якщо в функції необхідно застосовувати методи масиву, то перелік аргументів необхідно привести до масиву за допомогою методів:

// // ❗️ Метод Array.from(arguments) - перетворює вісь набір аргументів в масив. Метод викликається на псевдомасиві після отримання аргументів:

// add(1, 2, 3, 4)

// function add() {
//   console.log(arguments); // Arguments(4) [1, 2, 3, 4, callee: (...), Symbol(Symbol.iterator): ƒ] - псевдомасив
//   const array = Array.from(arguments);
//   console.log(array); // [1, 2, 3, 4] - повноцінний масив
// }

// // ❗️ Оператор (...rest) - дозволяє одразу зібрати в масив вісь, або частину переліку за виключенням довільної кількості елементів з початку переліку (розпилює перелік).

// add(1, 2, 3, 4);
// function add(...array) {
//   console.log(array); //[1, 2, 3, 4] - одразу повноцінний масив
// }

// // ❗️❗️❗️ Дефолтні значення
// // Якщо в функції передумовлено використання явної кількості значень, а прийде кількість значень, менша за розрахункове, то може виникнути помилка, тому що для очікуваних, але не переданих значень буде встановлено undefound. Щоб такого уникнути, для параметрів потрібно додати дефолтне значення, наприклад рівне 0 (зазвичай - найменше, від розрахункових значень (0, '', [])):

// function sum(val0, val1 = 0) {
//   return val0 + val1;
// }
// console.log(sum(1, 2));
// console.log(sum(5));
// console.log(sum(3));

// // Приклад задачі: отримати з масиву різних значень-елементів однорівневий масив:

// // отримується набір аргументів для побудови кінцевого масиву:
// function flatArray(array) {
//   // оголошуємо змінну, в яку будемо збирати отримані аргументи з порожнім вмістом
//   const newArray = [];
//   // основна логіка - принцип, за яким будемо наповнювати масив кінцевого результату:
//   // запускаємо цикл for...of для перебору на кожній операції елементу з заданого масиву, де elem - отриманий аргумент, array - масив отриманих аргументів:
//   for (const elem of array) {
//     // задаємо умову, чи елемент є масивом, використовуючи метод Array.isArray для елемента (повертає true або false) - якщо true, то потрапляння в тіло if, інакше - виконується код в else:
//     if (Array.isArray(elem)) {
//       // виконання коду, при умові true (елемент є масивом) - кожен item вкладеного масиву окремо пушиться в newArray:
//       for (const item of elem) {
//         newArray.push(item);
//       }
//     }
//     // якщо elem не масив (тобто, Array.isArray повернуло false, та минули тіло if), то додання цього elem до newArray:
//     else {
//       newArray.push(elem);
//     }
//   }
//   return newArray; // повернення результату
// }

// // Бінго! Але з масивами 1-го рівня вкладеності, якщо масиву будуть 2-го та нижче рівня вкладеності, потрібно ще перевіряти
// console.log(flatArray(['a', 5, ['3', 7, 8], '45', [1, 3, 7, 8]])); // ['a', '5', '3', '7', '8', '45', '1', '3', '7', '8']

// // ❗️❗️❗️ Паттерн раннього повернення
// // В функції може бути кілька ретурнів, якщо вони відокремлені своїма if - в таких випадках буде викониваться повренненя результату виконання за умовою. Наприклад, переврка можливості зняття коштів з банкомату:

// function withdraw(amount, balance) {
//     if (amount === 0) {
//         console.log('Для проведення операції введіть суму більшу за нуль');
//         return;
//     }
//     if (amount > balance) {
//         console.log('Недостатньо коштів на рахунку');
//         return;
// }
//     console.log('Операція зняття коштів проведена');
// };

// withdraw(0, 100); // 'Для проведення операції введіть суму більшу за нуль'
// withdraw(200, 100); // 'Недостатньо коштів на рахунку'
// withdraw(50, 100); // 'Операція зняття коштів проведена'


