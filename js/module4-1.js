'use strict';

// ❗️❗️❗️ Колбек-функції
// Функція - особливий тип даних, об'ект висшого порядку, який можно зберігати у змфінну або передавати в иншу функцію, використовуючи загальний синтаксис передачи аргумента.
// Колбек-функція - цйе функція, яка передана в якості параметра в іншу функцію.
// Кколбек-функції використовуються у випадках:
// 1. виклик функції за умовою (виконується одна з запропонованих функцій)
// 2. виклик функції по подією (наприклад, клік по кнопці на фронт-енде)
// 3. виклик отложенної функції - якщо ії необхідно виконати через якийсь час
// 4. функція виконується за результом роботи функції, яка виклмикає ії, наприклад по обробці/отримані даних з бек=енду

// function hello(name) {
//   return `Hello, ${name}`;
// }

// console.log(hello('Vitalii')); // 'Hello, Vitalii' - виклик функції
// console.log(hello); // вивід тіла функції в консоль без ії виклику - передається посилання на функцію

// Функція зворотнього виклику (callback) - функція яка передається в іншу функцію в якості аргумента, та приймаюча функція виконує виклик солбек-функції.
// Функція вищого порядку (haigh order function) - функція, яка приймає інши функції (колбек-функції) в якості параметра, та виконує ії та повертає результат виконання, або використовує цей результат для виконання своїх інструкцій. В функцїю вищого порядку передається посилання на колбек функцію (зберігаеться в пам'яті, як об'ект) для запуску іїї за умовою.

// function hello(name) { // колбек-функція
//   console.log(`Hello, ${name}`);
// }

// function greeting(name, callback) { // функцйія вищого порядку
//   console.log(`Greet ${name}`);
//   callback(name);
// }

// greeting('Vitalii', hello); // передавання функції hello як аргумент для функції greeting, та вона використовується при викроннанні функції

// inline-функція: маленьку функцію можна передати як параметр:
// function greeting(name, callback) {
//   console.log(`Greet ${name}`);
//   callback(name);
// }

// greeting('Vitalii', function hello(name) { // інлайн функція - вся функція записана у вигляді параметра.
//   console.log(`Hello, ${name}`);
// });

// Декілька колбеків - функція може отримувати в якості аргументів кілька колбек-функцій, наприклад у випадку. якщо потрібно виконати різні функції при різних ситуаціях - різних умовах

// function sendMessage(user, userStatusActive, userStatusNonActive) {
//   // тіло функції
// }
// function userStatusActive() { };
// function userStatusNonActive() {};

// // Приклади-практика:

// const doMath = function (a, b, c, callback) {
//     const result = callback(a, b) * c;
//     console.log(result)
// }

// const add = function (x, y) {
//     return x + y;
// }

// const sub = function (x, y) {
//     return x - y;
// }

// doMath(2, 3, 7, add); // 35 - передали аргументгом колбек-функцию пілсумування
// doMath(5, 4, 10, sub); // 10 - передали аргументгом колбек-функцию віднімання

// Абстрагування повторень. Абстракція

// function printValue(value) {
//   console.log(value);
// }

// function prettyPrint(value) {
//   console.log("Logging value: ", value);
// }

// function repeat(n, action) {
//   for (let i = 0; i < n; i += 1) {
//     action(i);
//   }
// }

// // Передаємо printValue як callback-функцію
// repeat(3, printValue);
// // 0
// // 1
// // 2

// // Передаємо prettyPrint як callback-функцію
// repeat(3, prettyPrint);
// // Logging value: 0
// // Logging value: 1
// // Logging value: 2

// за допомогою колбек-функціїї можна забеспечити синхронное (у встановленному порядку) виконання скрипта (доречно, коли функція, яка виконується з затримкою по причине великої інструкціі, або за очикуванням відповіді з бекенд, - то наступна коротка функція може бути виконана скоріше, але повинна бути виконана ПІСЛЯ виконнання попередньої функції)
// класичний приклад: якщо функція first буде виконуваться довго, то коротша функція second виведе відповідь раніше
// function first() {
//   console.log(1);
// }

// function second() {
//   console.log(2);
// }

// first(); // 1
// second(); // 2

// // завдання послідовності виконання функціі:
// function first(y) { // передаємо в функцію змінну
//     console.log(1); // відпрацьовує вивід 1
//     y() // для змынноъ використовуэться функцыя second (як аргумент зі рядка виклику функції first) - повертае ще й вивід 2
// }

// function second() {
//   console.log(2);
// }

// first(second); //  в якості аргументра передаємо другу функцію



// ❗️❗️❗️ Метод forEach

// const numbers = [5, 10, 15, 20, 25];

// // Класичний for
// for (let i = 0; i < numbers.length; i += 1) {
//   console.log(`Індекс ${i}, значення ${numbers[i]}`);
// }

// // Метод перебирання forEach
// numbers.forEach(function (number, index) {
//   console.log(`Індекс ${index}, значення ${number}`);
// });

// Метод forEach неможливо перервати, тому якщо потрібно перервати перебірання масиву значень в якись момент (знайдено потрібне число) то варто використовувати класічний for

// // ❗️❗️❗️ Стрілочні функції - використовуються якщо потрібно отримати змінну як результат виколнання функції. Після стрілки ( => ) ставиться ії тіло

// // Звичайне оголошення функції
// function classicAdd(a, b, c) {
//   return a + b + c;
// }

// // Те саме стрілочною функцією
// const addNumbers = (a, b, c) => {
//   // викорпистовуємо круглі дужки для оголошення кількох параметрів
//   return a + b + c;
// };

// const add = a => {
//   // якщо параметр одн - дужки не потрібні
//   return (a += 5);
// };

// const hello = () => {
//   // якщо параметрів немає, пусти дужки обов'язкові
//   return `Hello!`;
// };

// console.log(classicAdd(1, 2, 3)); // 6
// console.log(addNumbers(1, 2, 3)); // 6
// console.log(add(2)); // 7
// console.log(hello()); // Hello!

// // Тіло функції може бути як в дужках літерала ( {} ) так ы без:

// const sum1 = (a, b) => { // якщо дужки використані, то потрібно ставити return
//   return a + b;
// };

// const sum2 = (a, b) => a + b; // повретається результат виразу. нееявне повернення. Використовується тільки коли функціі не потрібне виконувати додаткових інструкцій, а потрібно повернути якесь значення

// console.log(sum1(1, 2)); // 3
// console.log(sum2(1, 2)); // 3

// // якщо потрібно зібрати кілька аргументів в масив, то іикористовується операція ...rest
// const arrow = (...args) => {
//     console.log(args);
// }

// arrow(1, 2, 3); // [1, 2, 3]

// ❗️❗️❗️ Стрілочні функції - колбеки\
// Анонімни (без назви) стрілочні функції використовуються як колбеки для перебіраюцих методів масиву у випадках якщо не потрібне тіло цієї функції

// const numbers = [5, 10, 15, 20, 25];

// // Оголошення функції
// numbers.forEach(function (number, index) {
//   console.log(`Індекс ${index}, значення ${number}`);
// });

// // Анонімна стрілочна функція
// numbers.forEach((number, index) => {
//   console.log(`Індекс ${index}, значення ${number}`);
// });

// можливе окреме оголошення стрілочної функціі

// const numbers = [5, 10, 15, 20, 25];

// const logMessage = (number, index) => { // оголошення стрілочної функції з виконанням инструкціі в тілі
//   console.log(`Індекс ${index}, значення ${number}`);
// };

// numbers.forEach(logMessage); // виклик методу forEach з переданням віиконання стрілочної функції в аргументі

// ❗️❗️❗️ Замикання
// функція може приймати в себе іншу функцію як аргумент, або повертати з сеье іншу функцію як резуцльтат виконання (тіло функціі, об'явоенної внутрі виконуючей функції). Можливість виклику функції як значення змінної, при цьому повернена функція буде мати доступ до всіх локальних параметрів та змінних (області відимості) в тілі батьківської функції.
//  Це можливість іншої функції отримувати доступ до лакальних змінних повернутої функції, незалежно від того, де була викликана ця функція


// ❗️❗️❗️ Різновиди коду
// Імперативне программування - описує проццесс обчислення в заданної послидовності виконання інструкцій.
// Декларативне программування - описує результат, порядок та спосіб не важливи. Вказуцємо, що хочемо отримати, використовуючи методи та функції. Імператівність виконання методів та функцій - під капотом.
// Імперативний підхід
// const numbers = [1, 2, 3, 4, 5];
// const filteredNumbers = [];

// for (let i = 0; i < numbers.length; i += 1) {
//   if (numbers[i] > 3) {
//     filteredNumbers.push(numbers[i]);
//   }
// }

// console.log(filteredNumbers); // [4, 5]

// // Декларативний підхід
// const numbers = [1, 2, 3, 4, 5];
// const filteredNumbers = numbers.filter(value => value > 3); // використано метод filter() (Array.prototype.filter())
// console.log(filteredNumbers); // [4, 5]