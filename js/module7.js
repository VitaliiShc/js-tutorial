// // ❗️❗️❗️ Поширення подій (event propagation)
// // Кожна поія проходе 3 фази:
// // - Звнурення (Capturing phase) - починається на window та закінчуєтиься на елементі, на якому відбулапся дія.
// // - Таргетінг (Target phase) - подія дійшла джо цельового елемента, містить повідомлення, що на цьоаму елементі відбуласмя подія.
// // - Спливання (Bubbeling phase) - подія спливає від цільового елемента через усіф еоементи-предки до window. Фаза використовується на практиці (найчастіше).
// // Під час настання події обробники спочатку спрацьовують на найбільш вкладеному елементі, потім на батьківському, і так далі вище. Таким чином, при спливанні події будут виконуватись обробникі подій на кожному елементі предку, на якому є слухач однотипноїх події, та викликати всі обробники на своєму шляху. Для спростування спливу викликається метод event.stopPropagation().
// // ❗️ Метод event.stopPropagation() зупиняє спливання та обробку події слухачамі елементів-предків (запобігає спрацьовуванню обробки події слухачамі предків).
// // ❗️ Метод stopImmediatePropagation() зупиняє всі обробникі подій на поточному елементі (в місці застосування) та вище (не є бажаним, тому що в системі можуть виконувартися обробникі подій для аналітики, або обробка подій, не урахованих в поточному коді/скрипті)

// // ❗️ Властивість event.target - найглибший елемент, на якому спфймано подію.
// // event.target - елемент, внутрі батьківського зі слухачем, на якому було викликано подію, тобто на якому було клікнуто.
// // event.currentTarget - елемент, на якому виконується обробник події, той елемент, на котрому увімкнуто слухач та виконується обробка події.

// // ❗️❗️❗️ Делегування подій
// // Якщо є группа сусідніх елементів, для яких потрібно однакову виконувати обробку однакових подій, то слухач та обробник подіі має сенс додавати на батьківського елемента та використовувати властивість event.target для ідентифікації того самого елемента нащадка, на якому виконалдася подія. Так як слухач займає місце в пас'яті, то це дозволяє не завантажувати пам'ять використанням кіфлькох слухачів, а застосовувати один слухач для безлічи дочірніх елементів. Також це дозволяє змінювати набір неащадкових елементів, не зачіпляючі та не змінюючі слухач та обробник події.
// // Для event.target обов 'язково необхідно перевіряти цільовой  елемент подіі для коректного ії опрацювання. Для цього використовується властивість nodeName, а назва тега елемента пишеться в UPPER_CASE:
// // if (event.target.nodeName !== "BUTTON") {
// //   return; // якщо клікнуто не на кнопку, то нічого не виконується - обробнике виконується лише на кліку на кнопку
// // }

// // ❗️❗️❗️ Trottle, Debounce
// // ❗️ Chatty events - події, що спрацьовують часто.ю наприклад відстеження переміщення миши/курсора, зміна розміру вікна, скроллб введення тексту ('input'). Такі події спрацьовують досить часто та маэ велике навантаження на браузер та викликають пробле ми с продуктывнысю, особливо якщо обробка таких подій має доси багато коду/функцій, але така часта обробка їх не має сенсу.
// // Trottle та Debounce - прийому з бібліотеці Lodash (https://lodash.com/), яки дозволяють ограничити частоту спрацювання слухача та виконання функції обробки події.

// // ❗️ CDN (Content Delivery Network) - географічно розподілена мирежева інфраструктура, яка забесмпечує швидку доставку контенту користувачам сайтів та веб-сервісів. Зберігає бібліотекі та інши сервіси та їх дозволяє підключати до сайту, забеспечующи макси мальну швідкість доставки до браузера користувача.

// // Підключення бібліотек може бути за посиланням - через додання посилання на скрипт в HTML (такім ож чином, як підключення скрипта js, але сама бібліотека може бути досить велика, та не бути використована в повному обсязі на робочому мічці користувача, а потрібні лише кілька окремих її частин) або локальною (заванитажено на станції розробника та експортом в js, а до браузера користувача буде відправлена тільки та частина коду бібліотеці, яка необхідна).




// const users = [
//   {
//     user: 'Mango',
//     age: 20,
//   },
//   {
//     user: 'Poly',
//     age: 30,
//   },
// ];

// const ages = users.map(({ age }) => {
//     console.log(age);
// return age});
// console.log(ages);
