// // // ❗️❗️❗️ Масиви
// // Масив - це колекція індексованих значень, котра починається з індексу 0. Індексована структура для зберігання та маніпулювання колекцією ОДНОТИПНИХ елементів (масив чисел, масив рядків, масив об'єктів (вкладених масивів)). Елементи масиву записуються всередині літерала масиву - квадратних дужках ( [ ] ). Тобто, квадратні дужки - це літерал, або позначення масиву (але при звернені до індексу рядка також використовуються квадратні дужки, але то синтаксис).
// const clients = ['Mango', 'Poly', 'Ajax'];
// console.table(clients);

// // Ітерабельні елементи - це сутність, яку можна перебрати по елементах, тобто ітерабельними є масив та рядок

// // typeOf для масиву повертає object. Тобто, масив - це об'єкт.
// // Щоб впевнитися, що ми працюємо з масивом застосовується метод Array.isArray() - якщо об'єкт - масив, то повертається true
// const clients = ['Mango', 'Poly', 'Ajax'];
// console.log(typeof clients);
// console.log(Array.isArray(clients));

// // Отримати значення елементу масиву можна за його індексом. Тобто, для доступу до елементів використовується конструкція масив[індекс]. При роботі з масивом звернення до його елементів виконується по індексу.
// console.log(clients[0]); // 'Mango'
// console.log(clients[1]); // 'Poly'
// console.log(clients[2]); // 'Ajax'
// console.log(clients[3]); // undefind - немає такого

// // для звертання до останнього елементу масиву використовується властивість його довжини з -1:
// console.log(clients[clients.length - 1]); // 'Ajax'

// // Елементи в масиву можна перевизначити, тобто призначити інше значення для елементу, звернувшись до нього за індексом. Виконується не перезапис або перепризначення змінної масиву, а змінюється тільки його елемент. Тобто, назва масиву - це ніби посилання на об'єкт (масив) та виконується зміна в об'єкті
// clients[0] = 'Kiwi';
// clients[1] = 'Pango';
// console.log(clients); // ["Kiwi", "Pango", "Ajax"] // замість ['Mango', 'Poly', 'Ajax']

// // Довжина масиву повертається властивістю length
// console.log(clients.length); // 3

// //Індекс останнього елементу масиву можна отримати за формулою 'довжина - 1'
// const lastElementIndex = clients.length - 1;
// console.log(lastElementIndex); // 2
// console.log(clients[lastElementIndex]); // 'Ajax'
// console.log(clients[clients.length - 1]); // 'Ajax'

// // ❗️❗️❗️ Ітерація (цикл) по масиву

// // ❗️ Цикл for перебирає всі елементи масиву. використовується, якщо є необхідність змінити елемент масиву та присвоїти йому нове значення.
// for (let i = 0; i < clients.length; i += 1) {
//   console.log(clients[i]);
// }

// // ❗️ Цикл for...of без лічильника. Перебирає всі елементи масиву. Застосовується, якщо немає необхідності зміняти значення елементів масиву
// // for (const variable of iterable) { тіло циклу }
// // variable - змінна, яка буде зберігати значення ітерабельного елемента на кожній ітерації
// // iterable - назва масиву або рядка, в якому потрібно шукати ітерабельні елементи
// const clients = ['Mango', 'Ajax', 'Poly'];
// for (const client of clients) {
//   console.log(client);
// }

// const string = 'javascript';
// for (const character of string) {
//   console.log(character);
// }

// // ❗️ Оператор break перериває цикл після (обов'язково!) знаходження заданого елемента
// // шукаємо в масиві елемент 'Poly'
// const clients = ['Mango', 'Ajax', 'Poly'];
// const clientNameToFind = 'Poly';
// let message;

// for (const client of clients) {
//   // на кожній ітерації буде перевірятися назва елементу, коли знайдено - виводиться повідомлення message, та закінчується виконання циклу
//   if (client === clientNameToFind) {
//     message = `It's ${client}`;
//     break;
//   }
//   // якщо не знайдено
//   message = `Елемент ${clientNameToFind} не знайдено`;
// }
// console.log(message);

// // рефакторинг коду - задати message по дефолту при хибному пошуку, а якщо знайдено - перевизначення

// const clients = ['Mango', 'Ajax', 'Poly'];
// const clientNameToFind = 'Poly';
// let message = `Елемент ${clientNameToFind} не знайдено`;
// for (const client of clients) {
//   if (client === clientNameToFind) {
//     message = `It's ${client}`;
//     break;
//   }
// }
// console.log(message);

// // ❗️ Оператор continue перериває поточну ітерацію, та продовжує цикл далі.
// // вивід чисел більших за певне значення

// const numbers = [1, 3, 14, 15, 18, 4, 7, 29, 6, 34];
// const threshold = 15;
// // для чисел, менших за порогове застосовується continue та дії поточної ітерації не виконуються
// for (let i = 0; i < numbers.length; i += 1) {
//   if (numbers[i] <= threshold) {
//     continue;
//   }
//   console.log(`Число ${numbers[i]} більше за ${threshold}`);
// }

// // ❗️❗️❗️ Присвоєння за посиланням і за значенням
// // При роботі з примітивами в змінної (const, let) виконується присвоєння самого значення. Та при порівнянні порівнюються значення примітиву.
// Але при роботі з масивами - браузер по літералу масиву розуміє, що це масив, та виділяє під масив комірку пам'яті та в змінної зберігає посилання на цю комірку.
// let a = 10;
// let b = a;
// console.log(a); // 10
// console.log(b); // 10
// console.log(a === b); // true
// a = 100; // перепризначили a
// console.log(a); // 100
// console.log(b); // 10 - перепризначення a було виконано після ініціалізації b, тому b залишилося колишнім
// console.log(a === b); // false - порівняння нового значення a та колишнього b

// const a = [1, 2, 3];
// const b = a;
// console.log(a); // [1, 2, 3]
// console.log(b); // [1, 2, 3]
// console.log(a === b); // true - порівнюються посилання на один і той же масив
// console.log([1, 2, 3] === [1, 2, 3]); // false - це різні масиви
// a[0] = 10; // перепризначення елементу масиву за індексом 0
// console.log(a); // [10, 2, 3] - зміна відбулася
// console.log(b); // [10, 2, 3] - також, зміна відображається, тому що посилання все теж на той самий масив, який було змінено

// const a = [1, 2, 3];
// a.length = 0; // патерн обнуління (очищення) масиву
// console.log(a); // повертає пустий масив
// a[2] = 100;
// console.log(a); // empty, empty, 100 (2 * пусто і 100)
// console.log(a[0]); // undefined - елемент з індексом 0 не знайдено

// const a = [1, 2, [3, 4]]; // масив в масиві
// console.log(a[2][0]); // 3 - звернення до масиву в масиві по індексу елемента в головному масиві, потім за індексом елемента во вкладеному масиві

// // ❗️❗️❗️ Методи
// // ❗️ Метод split(delimiter) - метод рядка, перетворює рядок на масив по вказаному деліметру (сепаратору) розділення елементів рядка. Повертає створений масив рядків (дозволяє перетворити рядок на масив, "розбивши" його по роздільнику delimiter; якщо роздільник - це порожній рядок, отримаємо масив окремих символів; роздільником може бути один або кілька символів.)
// const string = 'This is a string';
// console.log(string.split(' ')); // ['This', 'is', 'a', 'string'] - розділення по пробілу
// const word = 'Hello';
// console.log(word.split('')); // ['H', 'e', 'l', 'l', 'o'] - розділення по пустому рядку, тобто познаково
// const numbers = '1,2,3,4,5';
// console.log(numbers.split(',')); // ['1', '2', '3', '4', '5'] - розділення по комі. Але повертає в виразу рядків; для перетворення в числа необхідно виконати перебір та послідовне перетворення за допомогою циклу for, з попереднім оголошенням змінної для одержаного масиву:
// const numbersArray = numbers.split(',');  // ['1', '2', '3', '4', '5']
// for (let i = 0; i < numbersArray.length; i += 1) {
//   numbersArray[i] = Number(numbersArray[i]);
// }
// console.log(numbersArray); // [1, 2, 3, 4, 5] - масив чисел

// // ❗️ Метод join(delimiter) - перетворює масив в рядок зі вказаним деліметром (сепаратором) - зворотна операція методу split. Повертає створений рядок:
// const array = ['One', 'Two', 'Three'];
// console.log(array.join(' ')); // 'One Two Three'
// console.log(array.join(', ')); // 'One, Two, Three'

// const str = 'Mango';
// console.log(str.split('').join('-')); // 'M-a-n-g-o'
// console.log(typeof (str.split('').join('-'))); // string


// // ❗️ Метод revers() - змінює (перевертає) послідовність елементів масиву. Деструктивний(!) (мутуючий) - змінює сам масив, на якому був викликаний (якщо не за ініціалізацією нової змінної), для збереження оригінального масиву метод треба виконувати на копії (робиться через splice()). Повертає змінений масив:
// const array = ['One', 'Two', 'Three'];
// console.log(array); // ['One', 'Two', 'Three'];
// array.reverse();
// console.log(array); // ['Three', 'Two', 'One'];

// // ❗️ Метод indexOf(value) - виконується для отримання індексу шуканого елемента по першому збігу. Повертає індекс першого збігу або -1 якщо елемент не був знайдений.
// const array = ['One', 'Two', 'Three'];
// console.log(array.indexOf('Two')); // 1

// // ❗️ Метод includes(value) - виконує пошук вказаного значення серед елементів масиву та Повертає true або false.
// const array = ['One', 'Two', 'Three'];
// console.log(array.includes('Two')); // true

// // ❗️ Метод push(value, value...) - додає один або кілька вказаних елементів наприкінці масиву. Деструктивний(!), для збереження оригінального масиву метод треба виконувати на копії (робиться через splice()). Повертає нову довжину масиву:
// const array = ['One', 'Two', 'Three'];
// console.log(array.push('Four')); // 4
// console.log(array); // ['One', 'Two', 'Three', 'Four']

// // ❗️ Метод pop() - видаляє останній елемент з масиву. Деструктивний(!), для збереження оригінального масиву метод треба виконувати на копії (робиться через splice()). Повертає вилучений елемент (якщо масив порожній, то повертає undefind):
// const array = ['One', 'Two', 'Three'];
// console.log(array.pop()); // 'Three'
// console.log(array); // ['One', 'Two']

// // ❗️ Метод unshift(value, value...) - додає один або кілька вказаних елементів на початку масиву. Деструктивний(!), для збереження оригінального масиву метод треба виконувати на копії (робиться через splice()). Повертає нову довжину масиву:
// const array = ['One', 'Two', 'Three'];
// console.log(array.unshift('Four')); // 4
// console.log(array); // ['Four', 'One', 'Two', 'Three']

// // ❗️ Метод shift() - видаляє перший елемент з масиву. Деструктивний(!), для збереження оригінального масиву метод треба виконувати на копії (робиться через splice()). Повертає вилучений елемент (якщо масив порожній, то повертає undefind):
// const array = ['One', 'Two', 'Three'];
// console.log(array.shift()); // 'One'
// console.log(array); // ['Two', 'Three']

// // ❗️ Метод slice(begin, end) - відокремлює та копіює набір елементів з масиву з позиції begin за індексом включно і до позиції end за індексом не включно. Як і для рядка, можна використовувати від'ємне значення початку та кінця. Якщо end не вказано, то відокремлення виконується до кінця масиву (таким чином можна зробити копію всього масиву slice(0)). Не деструктивний. Повертає новий масив із вилучених елементів:
// const array = ['One', 'Two', 'Three', 'Four'];
// console.log(array.slice(1, 3)); // ['Two', 'Three']
// console.log(array.slice(1)); // ['Two', 'Three', 'Four']
// console.log(array.slice(0)); // ['One', 'Two', 'Three', 'Four']
// console.log(array); // ['One', 'Two', 'Three', 'Four']

// // ❗️ Метод splice(start, deleteCount, item0, item1...) - видаляє, додає, змінює елементи масиву. start - індекс позиції з якої починається зміна включно, deleteCount - кількість елементів для видалення, item0 - елемент, що додається (може бути кілька). Деструктивний(!) - змінює масив, на котрому викликається, для збереження оригінального масиву метод треба виконувати на копії (робиться через splice()). Повертає масив ВИЛУЧЕНИХ елементів:
// const cards = ['Card1', 'Card2', 'Card3', 'Card4', 'Card5'];

// // видалити 'Card2'і 'Card3' - 2 елемента з позиції за індексом 1:
// console.log(cards.splice(1, 2)); // ['Card2', 'Card3'] - повертає масив вилучених елементів
// console.log(cards); // ['Card1', 'Card4', 'Card5'] - масив змінився

// // видалити 'Card4' ([3] 1 шт) та додати 'Card6', 'Card7'
// console.log(cards.splice(3, 1, 'Card6', 'Card7')); //  ['Card4'] - повертає масив вилучених елементів
// console.log(cards); // ['Card1', 'Card2', 'Card3', 'Card6', 'Card7', 'Card5'] - масив змінився, нові картки додалися на місце вилученого елемента

// // додання без вилучання - вказується з якого індексу додавати, та видаляти 0 елементів
// console.log(cards.splice(3, 0, 'Card6', 'Card7')); //  [] - повертає пустий масив(нічого не вилучено)
// console.log(cards); // ['Card1', 'Card2', 'Card3', 'Card6', 'Card7', 'Card4', 'Card5'] - масив змінився, нові картки додалися на місце за індексом 3

// // ❗️ Метод concat(value1, value2) - об'єднує масиви, не деструктивний - повертає новий масив, для збереження оригінального масиву метод треба виконувати на копії (робиться через splice()). Додавання виконується до масиву, на якому був визваний метод та у вказаної черзі
// console.log([1,2,3].concat([4, 5], [6, 7])); // [1, 2, 3, 4, 5, 6, 7]
// const arr0 = ['Hello', 'world'];
// const arr1 = [1, 2];
// const arr2 = [[3, 4], ['!']];
// console.log(arr0.concat(arr1, arr2)); // ['Hello', 'world', 1, 2, [3, 4], ['!']]
// console.log(arr0.concat(arr2, arr1)); // ['Hello', 'world', [3, 4], ['!'], 1, 2]
// console.log(arr0.concat(arr1, arr1)); // ['Hello', 'world', 1, 2, 1, 2]
// // Для розвертання вкладених в масив масивів (створити однорівневий масив, якщо існують вкладені в масив масиви) потрібно звернутися до них всередині методу:
// console.log(arr0.concat(arr2[1])); // ['Hello', 'world', '!']
// console.log(arr0.concat(arr1, arr2[0], arr2[1])); //  ['Hello', 'world', 1, 2, 3, 4, '!']

// // ❗️❗️❗️ Функції
// // Функція це підпрограма, незалежна частина коду, яка призначена для багаторазового використання для рішення однієї задачі з різними початковими значеннями. Кожна функція виконує однотипну дію, відрізняються тільки вхідні параметри.
// // ❗️ Function declaration - оголошення функції з ім'ям та звернення до неї по імені. Результат функції може бути отриманий з любого місця коду, як після оголошення функції, так і до неї

// const arr1 = [1, 2, 3];

// multipl(arr1); // [2, 4, 6]

// function multipl(arr) {
//   for (let i = 0; i < arr.length; i += 1) {
//     arr[i] *= 2;
//   }

//   console.log(arr);
// }

// const arr2 = [2, 4, 6];

// multipl(arr2); // [4, 8, 12]

// // ❗️ Function expression - Функціональний вираз, оголошення функції за допомогою змінної, та звернення до неї по імені змінної. Сама функція не має назви, а назву має змінна, в яку передається результат виконання функції. Результат функції може бути отриманий тільки після її оголошення- тому що результат, це змінна.

// const arr1 = [1, 2, 3];

// multipl(arr1); // буде помилка, тому що змінна, до котрої звертається вираз не оголошено раніше

// const multipl = function (arr) {
//   for (let i = 0; i < arr.length; i += 1) {
//     arr[i] *= 2;
//   }

//   console.log(arr);
// };

// const arr2 = [2, 4, 6];

// multipl(arr2); // [4, 8, 12]

// // ❗️ Оператор return - явне завдання, що потрібно повернути з функції, та після виконання return функція переривається, та все, що було вказано після return використовуватися не буде - виконується вихід з функції.
// // Ретурнів може бути кілька в функції, якщо в яких ось випадках потрібно перервати виконання функції за умовою =- патерн раннього повернення, наприклад при виконання розгалужень, або циклів

// // ❗️❗️❗️ Псевдомасив arguments
// // функції можна передати довільну кількість аргументів, без необхідності перераховувати їх в параметрах, за допомогою спеціальної змінної arguments. В такому випадку в параметри функції передається ітерабельний (доступний для перебору) перелік індексованих елементів, та функція використовує їх для виконання.
// // Але arguments - це не масив, а набір індексованих елементів, тому для нього не доступна більшість методів масиву, тому якщо в функції необхідно застосовувати методи масиву, то перелік аргументів необхідно привести до масиву за допомогою методів:

// // ❗️ Метод Array.from(arguments) - перетворює вісь набір аргументів в масив. Метод викликається на псевдомасиві після отримання аргументів:

// add(1, 2, 3, 4)

// function add() {
//   console.log(arguments); // Arguments(4) [1, 2, 3, 4, callee: (...), Symbol(Symbol.iterator): ƒ] - псевдомасив
//   const array = Array.from(arguments);
//   console.log(array); // [1, 2, 3, 4] - повноцінний масив
// }

// // ❗️ Оператор (...rest) - дозволяє одразу зібрати в масив вісь, або частину переліку за виключенням довільної кількості елементів з початку переліку (розпилює перелік).

// add(1, 2, 3, 4);
// function add(...array) {
//   console.log(array); //[1, 2, 3, 4] - одразу повноцінний масив
// }

// // ❗️❗️❗️ Дефолтні значення
// // Якщо в функції передумовлено використання явної кількості значень, а прийде кількість значень, менша за розрахункове, то може виникнути помилка, тому що для очікуваних, але не переданих значень буде встановлено undefound. Щоб такого уникнути, для параметрів потрібно додати дефолтне значення, наприклад рівне 0 (зазвичай - найменше, від розрахункових значень (0, '', [])):

// function sum(val0, val1 = 0) {
//   return val0 + val1;
// }
// console.log(sum(1, 2));
// console.log(sum(5));
// console.log(sum(3));

// // Приклад задачі: отримати з масиву різних значень-елементів однорівневий масив:

// // отримується набір аргументів для побудови кінцевого масиву:
// function flatArray(array) {
//   // оголошуємо змінну, в яку будемо збирати отримані аргументи з порожнім вмістом
//   const newArray = [];
//   // основна логіка - принцип, за яким будемо наповнювати масив кінцевого результату:
//   // запускаємо цикл for...of для перебору на кожній операції елементу з заданого масиву, де elem - отриманий аргумент, array - масив отриманих аргументів:
//   for (const elem of array) {
//     // задаємо умову, чи елемент є масивом, використовуючи метод Array.isArray для елемента (повертає true або false) - якщо true, то потрапляння в тіло if, інакше - виконується код в else:
//     if (Array.isArray(elem)) {
//       // виконання коду, при умові true (елемент є масивом) - кожен item вкладеного масиву окремо пушиться в newArray:
//       for (const item of elem) {
//         newArray.push(item);
//       }
//     }
//     // якщо elem не масив (тобто, Array.isArray повернуло false, та минули тіло if), то додання цього elem до newArray:
//     else {
//       newArray.push(elem);
//     }
//   }
//   return newArray; // повернення результату
// }

// // Бінго! Але з масивами 1-го рівня вкладеності, якщо масиву будуть 2-го та нижче рівня вкладеності, потрібно ще перевіряти
// console.log(flatArray(['a', 5, ['3', 7, 8], '45', [1, 3, 7, 8]])); // ['a', '5', '3', '7', '8', '45', '1', '3', '7', '8']

// // ❗️❗️❗️ Паттерн раннього повернення
// // В функції може бути кілька ретурнів, якщо вони відокремлені своїма if - в таких випадках буде викониваться повренненя результату виконання за умовою. Наприклад, переврка можливості зняття коштів з банкомату:

// function withdraw(amount, balance) {
//     if (amount === 0) {
//         console.log('Для проведення операції введіть суму більшу за нуль');
//         return;
//     }
//     if (amount > balance) {
//         console.log('Недостатньо коштів на рахунку');
//         return;
// }
//     console.log('Операція зняття коштів проведена');
// };

// withdraw(0, 100); // 'Для проведення операції введіть суму більшу за нуль'
// withdraw(200, 100); // 'Недостатньо коштів на рахунку'
// withdraw(50, 100); // 'Операція зняття коштів проведена'
